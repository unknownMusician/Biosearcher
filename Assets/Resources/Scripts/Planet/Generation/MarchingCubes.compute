#pragma kernel GeneratePoints
#pragma kernel GenerateMesh

// EdgeConnection lists the index of the endpoint vertices for each 
// of the 12 edges of the cube.
// edgeConnection[12][2]
Texture2D<float> EdgeIndex2PointIndexesT;

// For any edge, if one vertex is inside of the surface and the other 
// is outside of the surface then the edge intersects the surface.
// For each of the 8 vertices of the cube can be two possible states,
// either inside or outside of the surface.
// For any cube the are 2^8=256 possible sets of vertex states.
// This table lists the edges intersected by the surface for all 256 
// possible vertex states. There are 12 edges.  
// For each entry in the table, if edge #n is intersected, then bit #n is set to 1.
// cubeEdgeFlags[256]
Texture2D<float> PointsHash2EdgesHashT;

// For each of the possible vertex states listed in cubeEdgeFlags there is a specific triangulation
// of the edge intersection points.  triangleConnectionTable lists all of them in the form of
// 0-5 edge triples with the list terminated by the invalid value -1.
// For example: triangleConnectionTable[3] list the 2 triangles formed when corner[0] 
// and corner[1] are inside of the surface, but the rest of the cube is not.
// triangleConnectionTable[256][16]
Texture2D<float> PointsHash2EdgesIndexesT;




struct MarchPoint
{
    float3 position;
    float value;
};

struct MarchCube
{
    MarchPoint points[8];
};

RWStructuredBuffer<MarchPoint> points;
RWTexture2D<float4> meshV3T1;
float3 chunkPosition;
float surfaceValue;
int cubeSize;

int pointsSize1D;
int cubesSize1D;

float Noise(float3 position)
{
    float noise = (sin(dot(position, float3(12.9898f, 78.233f, 128.544f) * 2.0f) * length(position)) * 43758.5453f) % 1;
    return abs(noise);
}

float3 SmoothNoise(float3 x)
{
    return x * x * x * (x * (x * 6 - 15) + 10);
}

float GradientNoise(float3 position)
{
    int3 wholePart = floor(position);
    // todo
    float3 fractPart = position % 1;
    // todo
    fractPart += float3(position.x < 0 && fractPart.x != 0 ? 1 : 0, position.y < 0 && fractPart.y != 0 ? 1 : 0, position.z < 0 && fractPart.z != 0 ? 1 : 0);
    fractPart = SmoothNoise(fractPart);
    float noisesZ[2];
    for (int z = 0; z < 2; z++)
    {
        float noisesY[2];
        for (int y = 0; y < 2; y++)
        {
            float noisesX[2];
            for (int x = 0; x < 2; x++)
            {
                noisesX[x] = Noise(wholePart + int3(x, y, z));
            }
            noisesY[y] = lerp(noisesX[0], noisesX[1], fractPart.x);
        }
        noisesZ[z] = lerp(noisesY[0], noisesY[1], fractPart.y);
    }
    return lerp(noisesZ[0], noisesZ[1], fractPart.z);
}

float Noise2Mountain(float gradientNoise)
{
    float x = gradientNoise;
    return x * x * x * x;
}

// todo: not in sync with CPU (+~)
float GenerateValue(float3 position)
{
    float result = 1;
    float3 normalizedPosition = normalize(position);

    // 400 - planet size (todo)
    float planetRadius = length(position) / 400;
    //float planetRadius = length(position*2) - 400;

    //planetRadius += GradientNoise(normalizedPosition / (cubesSize1D * (1 << 5))) / 1.5f;
    
    // Mountains
    float preMountainNoise = 1;
    preMountainNoise *= GradientNoise(normalizedPosition * (cubesSize1D * (1 << 2)));
    preMountainNoise *= GradientNoise(normalizedPosition * (cubesSize1D * (1 << 3)));
    float mountainMask = smoothstep(0.3, 0.1, GradientNoise(normalizedPosition * (cubesSize1D / uint(1 << 1))));
    planetRadius -= (Noise2Mountain(preMountainNoise) + 0.5) * mountainMask * 0.15;
    
    // Hills
    planetRadius -= GradientNoise(normalizedPosition * (cubesSize1D * (1 << 0))) * (1 - mountainMask) * 0.02;
    // todo
    //result *= 1 - GradientNoise(position / (cubesSize1D * (1 << 1))) / 16;
    //result *= 1 - GradientNoise(position / (cubesSize1D * (1 << 2))) / 8;
    //result *= 1 - GradientNoise(position / (cubesSize1D * (1 << 3))) / 4;
    //result *= 1 - GradientNoise(position / (cubesSize1D * (1 << 4))) / 2;
    //result *= 1 - GradientNoise(position / (cubesSize1D * (1 << 5))) / 1.5f;
    
    result *= 1 - clamp(planetRadius, 0, 1);

    return result;
}

uint MatrixId2ArrayId(uint x, uint y, uint z, int base)
{
    return x + y * base + z * base * base;
}

uint MatrixId2ArrayId(uint3 id, int base)
{
    return MatrixId2ArrayId(id.x, id.y, id.z, base);
}

uint2 MatrixId2TextureId(uint x, uint y, uint z, int base)
{
    return uint2(x + y * base, z);
}

uint2 MatrixId2TextureId(uint3 id, int base)
{
    return MatrixId2ArrayId(id.x, id.y, id.z, base);
}

MarchCube GenerateCube(RWStructuredBuffer<MarchPoint> points, uint3 id)
{
    MarchPoint cubePoints[8];
    int counter = 0;
    
    for (int y = 0; y < 2; y++) // todo
    {
        for (int z = 0; z < 2; z++)
        {
            for (int x = 0; x < 2; x++)
            {
                uint localXIndex = z == 0 ? x : 1 - x; // todo: ((1 - x) * y + x * (1 - y));
                uint localYIndex = y;
                uint localZIndex = 1 - z;
                cubePoints[counter] = points[MatrixId2ArrayId(id.x + localXIndex, id.y + localYIndex, id.z + localZIndex, pointsSize1D)];
                counter++;
            }
        }
    }
    
    MarchCube marchCube;
    marchCube.points = cubePoints;
    return marchCube;
}

int GetPointsHash(MarchCube cube, float surfaceValue)
{
    int cubeIndex = 0;
    // Find which vertices are inside of the surface and which are outside
    for (int i = 0; i < 8; i++)
    {
        if (cube.points[i].value <= surfaceValue)
        {
            cubeIndex |= 1 << i;
        }
    }
    return cubeIndex;
}

float3 Interpolate(MarchPoint point1, MarchPoint point2, float surfaceValue)
{
    float lerp = (surfaceValue - point1.value) / (point2.value - point1.value);
    float3 deltaPosition = point2.position - point1.position;
    return point1.position + deltaPosition * lerp;

    // return (point1.Position + point2.Position) / 2;
}

void AddFace(float3 face[3], uint faceId, uint cubeArrayId)
{
    int faceGlobalId = cubeArrayId * 5 + faceId;
    
    for (int i = 0; i < 3; i++)
    {
        int vertexGlobalId = faceGlobalId * 3 + i;
        meshV3T1[uint2(vertexGlobalId, 0)] = float4(face[i], vertexGlobalId); // todo: warning (if dimensions == 8)
    }
}

void March(MarchCube cube, float surfaceValue, uint cubeArrayId)
{
    int pointsHash = GetPointsHash(cube, surfaceValue);
    
    // Find which edges are intersected by the surface
    int edgesHash = PointsHash2EdgesHashT[uint2(pointsHash, 0)];
    
    // If the cube is entirely inside or outside of the surface, then there will be no intersections
    if (edgesHash == 0)
    {
        return;
    }
        
    // Save the triangles that were found. There can be up to five per cube
    for (int i = 0; i < 5; i++)
    {
        if (PointsHash2EdgesIndexesT[uint2(3 * i, pointsHash)] == 20.0)
        {
            break;
        }

        float3 face[3];
        
        for (int j = 0; j < 3; j++)
        {
            int edgeIndex = PointsHash2EdgesIndexesT[uint2(3 * i + j, pointsHash)];
            
            int edgePoint1Index = EdgeIndex2PointIndexesT[uint2(0, edgeIndex)];
            int edgePoint2Index = EdgeIndex2PointIndexesT[uint2(1, edgeIndex)];
            
            MarchPoint edgePoint1 = cube.points[edgePoint1Index];
            MarchPoint edgePoint2 = cube.points[edgePoint2Index];

            face[j] = Interpolate(edgePoint1, edgePoint2, surfaceValue);
        }

        AddFace(face, i, cubeArrayId);
    }
}

void PrepareBuffer(int cubeIndex)
{
    for (int i = 0; i < 15; i++)
    {
        meshV3T1[uint2(cubeIndex * 15 + i, 0)] = float4(0, 0, 0, -1);
    }
}

[numthreads(9, 9, 9)]
void GeneratePoints(uint3 threadId : SV_DispatchThreadID)
{
    MarchPoint marchPoint;
    
    int pointIndex = MatrixId2ArrayId(threadId, pointsSize1D);
    
    int3 position = (threadId - uint(pointsSize1D - 1) / uint(2)) * cubeSize;
    
    marchPoint.position = position;
    marchPoint.value = GenerateValue(position + chunkPosition);
    
    // todo
    //if (threadId.x < 9 && threadId.y < 9 && threadId.z < 9)
    //{
        points[pointIndex] = marchPoint;
    //}
}

[numthreads(8, 8, 8)]
void GenerateMesh(uint3 threadId : SV_DispatchThreadID)
{
    uint cubeArrayId = MatrixId2ArrayId(threadId, cubesSize1D);
    
    //float testValue = float(PointsHash2EdgesHashT[uint2(threadId.x + threadId.y * 6 + threadId.z * 6 * 6, 0)]);
    //float testValue = 56;
    //meshV3T1[cubeIndex] = float4(marchCube.points[0].position, 0);
    //meshTriangles[uint2(1, 0)] = 8.0;
    
    //return;
    
    PrepareBuffer(cubeArrayId);
    
    MarchCube marchCube = GenerateCube(points, threadId);
    
    March(marchCube, surfaceValue, cubeArrayId);

}
