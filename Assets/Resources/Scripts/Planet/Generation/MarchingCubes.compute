#pragma kernel GeneratePoints
#pragma kernel GenerateMesh

// EdgeConnection lists the index of the endpoint vertices for each 
// of the 12 edges of the cube.
// edgeConnection[12][2]
Texture2D<float> EdgeIndex2PointIndexesT;

// For any edge, if one vertex is inside of the surface and the other 
// is outside of the surface then the edge intersects the surface.
// For each of the 8 vertices of the cube can be two possible states,
// either inside or outside of the surface.
// For any cube the are 2^8=256 possible sets of vertex states.
// This table lists the edges intersected by the surface for all 256 
// possible vertex states. There are 12 edges.  
// For each entry in the table, if edge #n is intersected, then bit #n is set to 1.
// cubeEdgeFlags[256]
Texture2D<float> PointsHash2EdgesHashT;

// For each of the possible vertex states listed in cubeEdgeFlags there is a specific triangulation
// of the edge intersection points.  triangleConnectionTable lists all of them in the form of
// 0-5 edge triples with the list terminated by the invalid value -1.
// For example: triangleConnectionTable[3] list the 2 triangles formed when corner[0] 
// and corner[1] are inside of the surface, but the rest of the cube is not.
// triangleConnectionTable[256][16]
Texture2D<float> PointsHash2EdgesIndexesT;




struct MarchPoint
{
    float3 position;
    float value;
};

struct MarchCube
{
    MarchPoint points[8];
};

RWStructuredBuffer<MarchPoint> points;
RWStructuredBuffer<float3> meshVertices;
RWStructuredBuffer<int> meshTriangles;
float3 chunkPosition;
float surfaceValue;
int cubeSize;

int pointsSize1D;
int cubesSize1D;

float Noise(float3 position)
{
    float noise = (sin(dot(position, float3(12.9898f, 78.233f, 128.544f) * 2.0f) * length(position)) * 43758.5453f) % 1;
    return abs(noise);
}

float3 SmoothNoise(float3 x)
{
    return x * x * x * (x * (x * 6 - 15) + 10);
}

float GradientNoise(float3 position)
{
    int3 wholePart = floor(position);
    // todo
    float3 fractPart = position % 1;
    // todo
    fractPart += float3(position.x < 0 && fractPart.x != 0 ? 1 : 0, position.y < 0 && fractPart.y != 0 ? 1 : 0, position.z < 0 && fractPart.z != 0 ? 1 : 0);
    fractPart = SmoothNoise(fractPart);
    float noisesZ[2];
    for (int z = 0; z < 2; z++)
    {
        float noisesY[2];
        for (int y = 0; y < 2; y++)
        {
            float noisesX[2];
            for (int x = 0; x < 2; x++)
            {
                noisesX[x] = Noise(wholePart + int3(x, y, z));
            }
            noisesY[y] = lerp(noisesX[0], noisesX[1], fractPart.x);
        }
        noisesZ[z] = lerp(noisesY[0], noisesY[1], fractPart.y);
    }
    return lerp(noisesZ[0], noisesZ[1], fractPart.z);
}

// todo: not in sync with CPU (+~)
float GenerateValue(float3 position)
{
    float result = 1;

    // todo
    result *= 1 - GradientNoise(position / (6 * (1 << 1))) / 16;
    result *= 1 - GradientNoise(position / (6 * (1 << 2))) / 8;
    result *= 1 - GradientNoise(position / (6 * (1 << 3))) / 4;
    result *= 1 - GradientNoise(position / (6 * (1 << 4))) / 2;
    result *= 1 - GradientNoise(position / (6 * (1 << 5))) / 1.5f;

    // 100 - planet size (todo)
    result *= 1 - clamp(length(position) / 400, 0, 1);

    return result;
}

uint MatrixId2ArrayId(uint x, uint y, uint z, int base)
{
    return x + y * base + z * base * base;
}

uint MatrixId2ArrayId(uint3 id, int base)
{
    return MatrixId2ArrayId(id.x, id.y, id.z, base);
}

MarchCube GenerateCube(RWStructuredBuffer<MarchPoint> points, uint3 id)
{
    MarchPoint cubePoints[8];
    int counter = 0;
    
    for (int y = 0; y < 2; y++) // todo
    {
        for (int z = 0; z < 2; z++)
        {
            for (int x = 0; x < 2; x++)
            {
                uint localXIndex = z == 0 ? x : 1 - x; // todo: ((1 - x) * y + x * (1 - y));
                uint localYIndex = y;
                uint localZIndex = 1 - z;
                cubePoints[counter] = points[MatrixId2ArrayId(id.x + localXIndex, id.y + localYIndex, id.z + localZIndex, pointsSize1D)];
                counter++;
            }
        }
    }
    
    MarchCube marchCube;
    marchCube.points = cubePoints;
    return marchCube;
}

int GetPointsHash(MarchCube cube, float surfaceValue)
{
    int cubeIndex = 0;
    // Find which vertices are inside of the surface and which are outside
    for (int i = 0; i < 8; i++)
    {
        if (cube.points[i].value <= surfaceValue)
        {
            cubeIndex |= 1 << i;
        }
    }
    return cubeIndex;
}

float3 Interpolate(MarchPoint point1, MarchPoint point2, float surfaceValue)
{
    float lerp = (surfaceValue - point1.value) / (point2.value - point1.value);
    float3 deltaPosition = point2.position - point1.position;
    return point1.position + deltaPosition * lerp;

    // return (point1.Position + point2.Position) / 2;
}

void AddFace(float3 face[3], uint faceId, uint cubeArrayId)
{
    int faceGlobalId = cubeArrayId * 5 + faceId;
    
    for (int i = 0; i < 3; i++)
    {
        
        int vertexGlobalId = faceGlobalId * 3 + i;
        meshVertices[vertexGlobalId] = face[i]; // todo: warning (if dimensions == 8)
        meshTriangles[vertexGlobalId] = vertexGlobalId; // todo: warning (if dimensions == 8)
    }
}

void March(MarchCube cube, float surfaceValue, uint cubeArrayId)
{
    
    int pointsHash = GetPointsHash(cube, surfaceValue);
    
    // Find which edges are intersected by the surface
    //int edgesHash = PointsHash2EdgesHashT.Load(uint3(pointsHash, 0, 0));
    int edgesHash = PointsHash2EdgesHashT[uint2(pointsHash, 0)];
    // PointsHash2EdgesHashT[pointsHash];
    
    // If the cube is entirely inside or outside of the surface, then there will be no intersections
    if (edgesHash == 0)
    {
        return;
    }
    
    
    // meshVertices[cubeArrayId] = (PointsHash2EdgesHashT[uint2(cubeArrayId, 0)]).xxx;
    
    
    // Save the triangles that were found. There can be up to five per cube
    for (int i = 0; i < 5; i++)
    {
        
        //if (PointsHash2EdgesIndexesT.Load(uint3(3 * i, pointsHash, 0)) < 0) // PointsHash2EdgesIndexes[pointsHash][3 * i]
        if (PointsHash2EdgesIndexesT[uint2(3 * i, pointsHash)] == 20.0)
        {
            break;
        }

        float3 face[3];
        
        for (int j = 0; j < 3; j++)
        {
            //int edgeIndex = PointsHash2EdgesIndexesT.Load(uint3(3 * i + j, pointsHash, 0)); // PointsHash2EdgesIndexes[pointsHash][3 * i + j]
            int edgeIndex = PointsHash2EdgesIndexesT[uint2(3 * i + j, pointsHash)];
            
            //int edgePoint1Index = EdgeIndex2PointIndexesT.Load(uint3(0, edgeIndex, 0)); // EdgeIndex2PointIndexes[edgeIndex][0];
            //int edgePoint2Index = EdgeIndex2PointIndexesT.Load(uint3(1, edgeIndex, 0)); // EdgeIndex2PointIndexes[edgeIndex][1];
            int edgePoint1Index = EdgeIndex2PointIndexesT[uint2(0, edgeIndex)];
            int edgePoint2Index = EdgeIndex2PointIndexesT[uint2(1, edgeIndex)];
            
            MarchPoint edgePoint1 = cube.points[edgePoint1Index];
            MarchPoint edgePoint2 = cube.points[edgePoint2Index];

            face[j] = Interpolate(edgePoint1, edgePoint2, surfaceValue);
        }

        AddFace(face, i, cubeArrayId);
    }
}

void SetBuffer(int cubeIndex)
{
    for (int i = 0; i < 15; i++)
    {
        meshTriangles[cubeIndex * 15 + i] = -1;
        meshVertices[cubeIndex * 15 + i] = 0;
    }
}

[numthreads(7, 7, 7)]
void GeneratePoints(uint3 threadId : SV_DispatchThreadID)
{
    MarchPoint marchPoint;
    
    int pointIndex = MatrixId2ArrayId(threadId, pointsSize1D);
    
    int3 position = (threadId - uint(pointsSize1D - 1) / uint(2)) * cubeSize;
    
    marchPoint.position = position;
    marchPoint.value = GenerateValue(position + chunkPosition);
    
    points[pointIndex] = marchPoint;
}

[numthreads(6, 6, 6)]
void GenerateMesh(uint3 threadId : SV_DispatchThreadID)
{
    uint cubeArrayId = MatrixId2ArrayId(threadId, cubesSize1D);
    
    SetBuffer(cubeArrayId);
    
    MarchCube marchCube = GenerateCube(points, threadId);
    
    //float testValue = float(PointsHash2EdgesHashT[uint2(threadId.x + threadId.y * 6 + threadId.z * 6 * 6, 0)]);
    //float testValue = 56;
    //meshVertices[cubeIndex] = marchCube.points[0].position;
    //return;
    //meshVertices[1] = (8).xxx;
    
    March(marchCube, surfaceValue, cubeArrayId);

}
